#!/usr/bin/env bash
# shuu - Git Worktree Manager
# Bash 3.2 compatible

set -euo pipefail

VERSION="2.0.0"

# ── Colors ───────────────────────────────────────────────────────────

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── i18n (English defaults) ─────────────────────────────────────────

MSG_NOT_GIT_REPO="Please run inside a git repository"
MSG_GENERATING_BRANCH="Generating branch name..."
MSG_WHAT_TO_IMPLEMENT="What do you want to implement?"
MSG_ENTER_DESC="Please enter a description"
MSG_SELECT_BRANCH="Select branch name:"
MSG_ENTER_MANUALLY="Enter manually"
MSG_REGENERATE="Regenerate with feedback"
MSG_BRANCH_NAME="Branch name:"
MSG_FEEDBACK="Feedback:"
MSG_ENTER_BRANCH_NAME="Please enter a branch name"
MSG_ENTER_FEEDBACK="Please enter feedback"
MSG_WT_ALREADY_EXISTS="Worktree already exists"
MSG_CREATING_WT="Creating worktree..."
MSG_WT_CREATED="Worktree created"
MSG_WT_CREATED_EXISTING="Worktree created with existing branch"
MSG_WT_CREATE_FAILED="Failed to create worktree"
MSG_PATH="Path:"
MSG_BRANCH="Branch:"
MSG_TO_SWITCH="To switch:"
MSG_LIST_TITLE="Git Worktrees"
MSG_NO_WT_TO_REMOVE="No worktrees to remove"
MSG_SELECT_WT_REMOVE="Select worktree to remove:"
MSG_CONFIRM_DELETE="Are you sure you want to delete?"
MSG_CANCELLED="Cancelled"
MSG_WT_REMOVED="Worktree removed"
MSG_WT_REMOVE_FAILED="Failed to remove worktree"
MSG_FORCE_REMOVE="Force remove with --force?"
MSG_WT_FORCE_REMOVED="Worktree force removed"
MSG_FORCE_REMOVE_FAILED="Force remove also failed"
MSG_DELETE_BRANCH="Also delete branch '%s'?"
MSG_BRANCH_DELETED="Branch deleted"
MSG_FORCE_DELETE_BRANCH="Unmerged branch. Force delete?"
MSG_BRANCH_FORCE_DELETED="Branch force deleted"
MSG_NO_WT_TO_SWITCH="No worktrees to switch to"
MSG_SELECT_WT_SWITCH="Select worktree:"
MSG_SWITCHING_TO="Switching to %s"
MSG_MENU_TITLE="shuu - Git Worktree Manager"
MSG_MENU_CREATE="create  - Create worktree"
MSG_MENU_LIST="list    - List worktrees"
MSG_MENU_REMOVE="remove  - Remove worktree"
MSG_MENU_SWITCH="switch  - Switch worktree"
MSG_MENU_HELP="help    - Show help"
MSG_MENU_HINT="↑↓: move  Enter: select  q: cancel"
MSG_HELP_USAGE="USAGE"
MSG_HELP_COMMANDS="COMMANDS"
MSG_HELP_EXAMPLES="EXAMPLES"
MSG_HELP_NOTES="NOTES"
MSG_HELP_CREATE_DESC="Create worktree (AI branch name suggestion)"
MSG_HELP_LIST_DESC="List worktrees"
MSG_HELP_REMOVE_DESC="Remove worktree (interactive)"
MSG_HELP_SWITCH_DESC="Switch to worktree"
MSG_HELP_HELP_DESC="Show this help"
MSG_HELP_NOTE_PATH="Worktrees are created at ../<repo>-worktrees/<branch>"
MSG_HELP_NOTE_SWITCH="'shuu switch' cd requires sourcing shuu.zsh"
MSG_HELP_DIRECT_DESC="Create worktree directly from description"
MSG_MODEL_CURRENT="Current model: %s"
MSG_MODEL_SELECT="Select model:"
MSG_MODEL_SET="Model set to %s"
MSG_MODEL_NONE="(default)"
MSG_SETTINGS_TITLE="Settings"
MSG_SETTINGS_LANG="Language"
MSG_SETTINGS_MODEL="AI Model"
MSG_MENU_SETTINGS="settings - Settings"
MSG_HELP_SETTINGS_DESC="Configure language and AI model"
MSG_MODEL_CURRENT="Current model: %s"
MSG_MODEL_SELECT="Select model:"
MSG_MODEL_SET="Model set to %s"
MSG_MODEL_NONE="(default)"
MSG_LANG_CURRENT="Current language: %s"
MSG_LANG_SET="Language set to %s"
MSG_SETTINGS_RESET="Reset to defaults"
MSG_SETTINGS_RESET_DONE="Settings reset to defaults"

# ── Config ───────────────────────────────────────────────────────────

GWT_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/shuu"

# Load locale (priority: GWT_LANG env > config file > LANG env)
_load_locale() {
    local lang="${GWT_LANG:-}"
    if [[ -z "$lang" && -f "${GWT_CONFIG_DIR}/lang" ]]; then
        lang="$(cat "${GWT_CONFIG_DIR}/lang")"
    fi
    if [[ -z "$lang" ]]; then
        lang="${LANG%%.*}"
    fi
    local script_dir
    script_dir="$(cd "$(dirname "$0")" && pwd)"
    local locale_file="${script_dir}/locale/${lang%%_*}.sh"
    if [[ -f "$locale_file" ]]; then
        source "$locale_file"
    fi
}
_load_locale

# ── Helpers ──────────────────────────────────────────────────────────

err()     { printf "${RED}error:${NC} %s\n" "$1" >&2; }
info()    { printf "${CYAN}▸${NC} %s\n" "$1" >&2; }
success() { printf "${GREEN}✓${NC} %s\n" "$1" >&2; }

_gwt_cleanup() {
    tput cnorm >&2 2>/dev/null || true
}

_get_model() {
    local model_file="${GWT_CONFIG_DIR}/model"
    if [[ -f "$model_file" ]]; then
        cat "$model_file"
    fi
}

_set_model() {
    mkdir -p "$GWT_CONFIG_DIR"
    printf '%s' "$1" > "${GWT_CONFIG_DIR}/model"
}

_get_lang() {
    if [[ -f "${GWT_CONFIG_DIR}/lang" ]]; then
        cat "${GWT_CONFIG_DIR}/lang"
    fi
}

_set_lang() {
    mkdir -p "$GWT_CONFIG_DIR"
    printf '%s' "$1" > "${GWT_CONFIG_DIR}/lang"
}

# Language codes and native names (used by setup wizard and cmd_lang)
_LANG_CODES=("en" "ja" "fr" "es" "ru" "zh" "ar")
_LANG_NAMES=("English" "日本語" "Français" "Español" "Русский" "中文" "العربية")

require_git_repo() {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        err "$MSG_NOT_GIT_REPO"
        exit 1
    fi
}

# Get the main worktree directory (works from any worktree)
get_main_worktree() {
    git worktree list | head -1 | awk '{print $1}'
}

# Get worktrees directory (sibling of main worktree)
get_worktrees_dir() {
    local main_wt
    main_wt="$(get_main_worktree)"
    local repo_name
    repo_name="$(basename "$main_wt")"
    local parent
    parent="$(dirname "$main_wt")"
    printf '%s' "${parent}/${repo_name}-worktrees"
}

# ── select_menu ──────────────────────────────────────────────────────
# Interactive arrow-key menu. All display goes to stderr.
# Outputs selected index (0-based) to stdout. Returns 1 on cancel.
select_menu() {
    local title="$1"
    shift
    local items=("$@")
    local selected=0
    local total=${#items[@]}

    tput civis >&2 2>/dev/null || true
    trap '_gwt_cleanup; exit 130' INT TERM

    # Print title (once)
    printf "\n\033[1m%s\033[0m\n" "$title" >&2

    local redraw=0
    while true; do
        # On redraw, move cursor up to overwrite previous items + hint
        if [[ $redraw -eq 1 ]]; then
            printf '\r\033[%dA' "$total" >&2
        fi

        # Draw items
        local i=0
        while [[ $i -lt $total ]]; do
            printf '\033[2K' >&2
            if [[ $i -eq $selected ]]; then
                printf '  \033[0;32m▶ %s\033[0m\n' "${items[$i]}" >&2
            else
                printf '  \033[2m  %s\033[0m\n' "${items[$i]}" >&2
            fi
            i=$((i + 1))
        done
        printf '\033[2K\033[2m  %s\033[0m' "$MSG_MENU_HINT" >&2

        redraw=1

        # Read input
        IFS= read -rsn1 key

        local accept=0
        case "$key" in
            $'\x1b')
                IFS= read -rsn1 -t 0.05 seq1 || seq1=""
                if [[ -z "$seq1" ]]; then
                    # ESC key alone - cancel
                    printf '\n' >&2
                    tput cnorm >&2 2>/dev/null || true
                    trap - INT TERM
                    return 1
                fi
                IFS= read -rsn1 -t 0.05 seq2 || seq2=""
                case "${seq1}${seq2}" in
                    '[A') selected=$(( (selected - 1 + total) % total )) ;;
                    '[B') selected=$(( (selected + 1) % total )) ;;
                esac
                ;;
            k) selected=$(( (selected - 1 + total) % total )) ;;
            j) selected=$(( (selected + 1) % total )) ;;
            '') accept=1 ;;
            q|Q)
                printf '\n' >&2
                tput cnorm >&2 2>/dev/null || true
                trap - INT TERM
                return 1
                ;;
            [1-9])
                local num=$((key - 1))
                if [[ $num -lt $total ]]; then
                    selected=$num
                    accept=1
                fi
                ;;
        esac

        if [[ $accept -eq 1 ]]; then
            # Final redraw to show selection
            printf '\r\033[%dA' "$total" >&2
            local i=0
            while [[ $i -lt $total ]]; do
                printf '\033[2K' >&2
                if [[ $i -eq $selected ]]; then
                    printf '  \033[0;32m▶ %s\033[0m\n' "${items[$i]}" >&2
                else
                    printf '  \033[2m  %s\033[0m\n' "${items[$i]}" >&2
                fi
                i=$((i + 1))
            done
            printf '\033[2K\n' >&2
            tput cnorm >&2 2>/dev/null || true
            trap - INT TERM
            printf '%d' "$selected"
            return 0
        fi
    done
}

# ── first run setup ─────────────────────────────────────────────────

_check_first_run() {
    if [[ -f "${GWT_CONFIG_DIR}/lang" ]]; then
        return 0
    fi

    # Language selection (native names are universally readable)
    local items=()
    local i=0
    while [[ $i -lt ${#_LANG_CODES[@]} ]]; do
        items+=("${_LANG_NAMES[$i]}")
        i=$((i + 1))
    done

    local selected
    selected=$(select_menu "Select language / 言語選択" "${items[@]}") || exit 0

    local chosen_lang="${_LANG_CODES[$selected]}"
    _set_lang "$chosen_lang"

    # Reload locale with chosen language
    GWT_LANG="$chosen_lang"
    _load_locale

    # Model selection (now in chosen language)
    local model_ids=(
        "claude-sonnet-4-6"
        "claude-opus-4-6"
        "claude-haiku-4-5-20251001"
    )
    local model_labels=(
        "Sonnet 4.6  (claude-sonnet-4-6)"
        "Opus 4.6    (claude-opus-4-6)"
        "Haiku 4.5   (claude-haiku-4-5-20251001)"
    )

    local model_selected
    model_selected=$(select_menu "$MSG_MODEL_SELECT" "${model_labels[@]}") || exit 0

    _set_model "${model_ids[$model_selected]}"
    success "$(printf "$MSG_MODEL_SET" "${model_ids[$model_selected]}")"
    printf "\n" >&2
}

# ── generate_branch_name ────────────────────────────────────────────

generate_branch_name() {
    local description="$1"
    local feedback="${2:-}"
    local name=""

    if command -v claude >/dev/null 2>&1; then
        info "$MSG_GENERATING_BRANCH"
        local prompt="Suggest exactly one git branch name for the following implementation.
Rules:
- kebab-case
- English
- Short and concise (2-4 words)
- Use prefix: feat/, fix/, refactor/, etc.
- Output only the branch name (no explanation)

Implementation: ${description}"

        if [[ -n "$feedback" ]]; then
            prompt="${prompt}

Feedback on previous suggestion: ${feedback}"
        fi

        local model_args=()
        local model
        model="$(_get_model)"
        if [[ -n "$model" ]]; then
            model_args=(--model "$model")
        fi
        name="$(CLAUDECODE= claude "${model_args[@]}" -p "$prompt" 2>/dev/null || true)"
        name="$(echo "$name" | head -1 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    fi

    # Fallback
    if [[ -z "$name" ]]; then
        name="feat/$(echo "$description" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | sed 's/[^a-z0-9/-]//g' | cut -c1-40)"
    fi

    printf '%s' "$name"
}

# ── create ───────────────────────────────────────────────────────────

cmd_create() {
    require_git_repo

    local description="${1:-}"
    local worktrees_dir
    worktrees_dir="$(get_worktrees_dir)"

    if [[ -z "$description" ]]; then
        printf "${BOLD}%s${NC} " "$MSG_WHAT_TO_IMPLEMENT" >&2
        read -r description
        if [[ -z "$description" ]]; then
            err "$MSG_ENTER_DESC"
            exit 1
        fi
    fi

    # Generate branch name
    local suggested_name=""
    suggested_name="$(generate_branch_name "$description")"

    # Let user choose
    local branch_name=""
    while [[ -z "$branch_name" ]]; do
        local items=("$suggested_name" "$MSG_ENTER_MANUALLY" "$MSG_REGENERATE")
        local choice
        choice=$(select_menu "$MSG_SELECT_BRANCH" "${items[@]}") || exit 1

        case "$choice" in
            0)
                branch_name="$suggested_name"
                ;;
            1)
                printf "${BOLD}%s${NC} " "$MSG_BRANCH_NAME" >&2
                read -r user_name
                if [[ -n "$user_name" ]]; then
                    branch_name="$user_name"
                else
                    err "$MSG_ENTER_BRANCH_NAME"
                fi
                ;;
            2)
                printf "${BOLD}%s${NC} " "$MSG_FEEDBACK" >&2
                read -r feedback
                if [[ -n "$feedback" ]]; then
                    suggested_name="$(generate_branch_name "$description" "$feedback")"
                else
                    err "$MSG_ENTER_FEEDBACK"
                fi
                ;;
        esac
    done

    # Derive worktree directory name from branch (replace / with -)
    local wt_dirname
    wt_dirname="$(echo "$branch_name" | tr '/' '-')"
    local wt_path="${worktrees_dir}/${wt_dirname}"

    # Check if already exists
    if [[ -d "$wt_path" ]]; then
        err "$MSG_WT_ALREADY_EXISTS: ${wt_path}"
        exit 1
    fi

    # Create worktrees directory if needed
    mkdir -p "$worktrees_dir"

    # Create worktree with new branch
    info "$MSG_CREATING_WT"
    if git worktree add -b "$branch_name" "$wt_path" 2>/dev/null; then
        success "$MSG_WT_CREATED"
    elif git worktree add "$wt_path" "$branch_name" 2>/dev/null; then
        success "$MSG_WT_CREATED_EXISTING"
    else
        err "$MSG_WT_CREATE_FAILED"
        exit 1
    fi

    printf "\n" >&2
    printf "  ${DIM}%s${NC} %s\n" "$MSG_PATH" "$wt_path" >&2
    printf "  ${DIM}%s${NC} %s\n" "$MSG_BRANCH" "$branch_name" >&2
    printf "\n" >&2
    printf "${CYAN}▸${NC} %s ${BOLD}shuu switch${NC}\n" "$MSG_TO_SWITCH" >&2
}

# ── list ─────────────────────────────────────────────────────────────

cmd_list() {
    require_git_repo

    local main_wt
    main_wt="$(get_main_worktree)"

    printf "\n${BOLD}%s${NC}\n\n" "$MSG_LIST_TITLE" >&2

    while IFS= read -r line; do
        local wt_path wt_hash wt_branch
        wt_path="$(echo "$line" | awk '{print $1}')"
        wt_hash="$(echo "$line" | awk '{print $2}')"
        wt_branch="$(echo "$line" | awk '{print $3}' | tr -d '[]')"

        if [[ "$wt_path" == "$main_wt" ]]; then
            printf "  ${YELLOW}★${NC} ${BOLD}%-50s${NC} ${DIM}%s${NC}  ${GREEN}%s${NC}\n" \
                "$wt_path" "$wt_hash" "$wt_branch" >&2
        else
            printf "    %-50s ${DIM}%s${NC}  ${BLUE}%s${NC}\n" \
                "$wt_path" "$wt_hash" "$wt_branch" >&2
        fi
    done < <(git worktree list)

    printf "\n" >&2
}

# ── remove ───────────────────────────────────────────────────────────

cmd_remove() {
    require_git_repo

    local main_wt
    main_wt="$(get_main_worktree)"

    # Build list of removable worktrees (exclude main)
    local wt_paths=()
    local wt_branches=()
    while IFS= read -r line; do
        local wt_path wt_branch
        wt_path="$(echo "$line" | awk '{print $1}')"
        wt_branch="$(echo "$line" | awk '{print $3}' | tr -d '[]')"

        if [[ "$wt_path" != "$main_wt" ]]; then
            wt_paths+=("$wt_path")
            wt_branches+=("$wt_branch")
        fi
    done < <(git worktree list)

    if [[ ${#wt_paths[@]} -eq 0 ]]; then
        info "$MSG_NO_WT_TO_REMOVE"
        return 0
    fi

    # Build labels for menu
    local labels=()
    local i=0
    while [[ $i -lt ${#wt_paths[@]} ]]; do
        labels+=("${wt_branches[$i]}  ${wt_paths[$i]}")
        i=$((i + 1))
    done

    local selected
    selected=$(select_menu "$MSG_SELECT_WT_REMOVE" "${labels[@]}") || return 0

    local target_path="${wt_paths[$selected]}"
    local target_branch="${wt_branches[$selected]}"

    # Confirm
    printf "\n${RED}${BOLD}%s${NC}\n" "$MSG_CONFIRM_DELETE" >&2
    printf "  %s %s\n" "$MSG_PATH" "$target_path" >&2
    printf "  %s %s\n" "$MSG_BRANCH" "$target_branch" >&2
    printf "${BOLD}[y/N]:${NC} " >&2
    read -r confirm

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        info "$MSG_CANCELLED"
        return 0
    fi

    # Remove worktree
    if git worktree remove "$target_path" 2>/dev/null; then
        success "$MSG_WT_REMOVED: ${target_path}"
    else
        err "$MSG_WT_REMOVE_FAILED"
        printf "${BOLD}%s [y/N]:${NC} " "$MSG_FORCE_REMOVE" >&2
        read -r force_confirm
        if [[ "$force_confirm" == "y" || "$force_confirm" == "Y" ]]; then
            if git worktree remove --force "$target_path"; then
                success "$MSG_WT_FORCE_REMOVED"
            else
                err "$MSG_FORCE_REMOVE_FAILED"
                exit 1
            fi
        else
            exit 1
        fi
    fi

    # Ask about branch deletion
    printf "${BOLD}$(printf "$MSG_DELETE_BRANCH" "$target_branch") [y/N]:${NC} " >&2
    read -r delete_branch
    if [[ "$delete_branch" == "y" || "$delete_branch" == "Y" ]]; then
        if git branch -d "$target_branch" 2>/dev/null; then
            success "$MSG_BRANCH_DELETED: ${target_branch}"
        else
            printf "${BOLD}%s [y/N]:${NC} " "$MSG_FORCE_DELETE_BRANCH" >&2
            read -r force_branch
            if [[ "$force_branch" == "y" || "$force_branch" == "Y" ]]; then
                git branch -D "$target_branch"
                success "$MSG_BRANCH_FORCE_DELETED: ${target_branch}"
            fi
        fi
    fi
}

# ── switch ───────────────────────────────────────────────────────────

cmd_switch() {
    require_git_repo

    # Build list of all worktrees
    local wt_paths=()
    local wt_branches=()
    while IFS= read -r line; do
        local wt_path wt_branch
        wt_path="$(echo "$line" | awk '{print $1}')"
        wt_branch="$(echo "$line" | awk '{print $3}' | tr -d '[]')"
        wt_paths+=("$wt_path")
        wt_branches+=("$wt_branch")
    done < <(git worktree list)

    if [[ ${#wt_paths[@]} -le 1 ]]; then
        info "$MSG_NO_WT_TO_SWITCH"
        return 0
    fi

    # Build labels with (current) marker
    local current_dir
    current_dir="$(pwd -P)"
    local labels=()
    local i=0
    while [[ $i -lt ${#wt_paths[@]} ]]; do
        local label="${wt_branches[$i]}  ${wt_paths[$i]}"
        if [[ "$current_dir" == "${wt_paths[$i]}"* ]]; then
            label="${label} (current)"
        fi
        labels+=("$label")
        i=$((i + 1))
    done

    local selected
    selected=$(select_menu "$MSG_SELECT_WT_SWITCH" "${labels[@]}") || return 0

    local target_path="${wt_paths[$selected]}"
    success "$(printf "$MSG_SWITCHING_TO" "${wt_branches[$selected]}")"
    # Write target path to temp file for shell wrapper to cd
    printf "%s" "$target_path" > "/tmp/.shuu_cd_target"
}

# ── settings ─────────────────────────────────────────────────────────

_select_lang() {
    local items=()
    local current
    current="$(_get_lang)"
    local i=0
    while [[ $i -lt ${#_LANG_CODES[@]} ]]; do
        local label="${_LANG_NAMES[$i]}"
        if [[ "${_LANG_CODES[$i]}" == "$current" ]]; then
            label="${label} ★"
        fi
        items+=("$label")
        i=$((i + 1))
    done

    local selected
    selected=$(select_menu "$MSG_SETTINGS_LANG" "${items[@]}") || return 0

    local new_lang="${_LANG_CODES[$selected]}"
    _set_lang "$new_lang"
    GWT_LANG="$new_lang"
    _load_locale
    success "$(printf "$MSG_LANG_SET" "${_LANG_NAMES[$selected]}")"
}

_select_model() {
    local current
    current="$(_get_model)"

    local model_ids=(
        "claude-sonnet-4-6"
        "claude-opus-4-6"
        "claude-haiku-4-5-20251001"
    )
    local model_labels=(
        "Sonnet 4.6  (claude-sonnet-4-6)"
        "Opus 4.6    (claude-opus-4-6)"
        "Haiku 4.5   (claude-haiku-4-5-20251001)"
    )

    local items=()
    local i=0
    while [[ $i -lt ${#model_ids[@]} ]]; do
        local label="${model_labels[$i]}"
        if [[ "${model_ids[$i]}" == "$current" ]]; then
            label="${label} ★"
        fi
        items+=("$label")
        i=$((i + 1))
    done

    local selected
    selected=$(select_menu "$MSG_MODEL_SELECT" "${items[@]}") || return 0

    local new_model="${model_ids[$selected]}"
    _set_model "$new_model"
    success "$(printf "$MSG_MODEL_SET" "$new_model")"
}

_reset_settings() {
    rm -f "${GWT_CONFIG_DIR}/lang" "${GWT_CONFIG_DIR}/model"
    success "$MSG_SETTINGS_RESET_DONE"
}

cmd_settings() {
    # Resolve current language display name
    local current_lang
    current_lang="$(_get_lang)"
    local lang_display="$MSG_MODEL_NONE"
    local i=0
    while [[ $i -lt ${#_LANG_CODES[@]} ]]; do
        if [[ "${_LANG_CODES[$i]}" == "$current_lang" ]]; then
            lang_display="${_LANG_NAMES[$i]}"
            break
        fi
        i=$((i + 1))
    done

    local current_model
    current_model="$(_get_model)"
    local model_display="${current_model:-$MSG_MODEL_NONE}"

    local items=(
        "$MSG_SETTINGS_LANG  ($lang_display)"
        "$MSG_SETTINGS_MODEL  ($model_display)"
        "$MSG_SETTINGS_RESET"
    )

    local selected
    selected=$(select_menu "$MSG_SETTINGS_TITLE" "${items[@]}") || return 0

    case "$selected" in
        0) _select_lang ;;
        1) _select_model ;;
        2) _reset_settings ;;
    esac
}

# ── help ─────────────────────────────────────────────────────────────

cmd_help() {
    cat >&2 <<HELP

${BOLD}shuu${NC} - Git Worktree Manager v${VERSION}

${BOLD}${MSG_HELP_USAGE}:${NC}
    shuu <command>
    shuu "<description>"       ${MSG_HELP_DIRECT_DESC}

${BOLD}${MSG_HELP_COMMANDS}:${NC}
    ${GREEN}create${NC}  (c)      ${MSG_HELP_CREATE_DESC}
    ${GREEN}list${NC}    (l, ls)  ${MSG_HELP_LIST_DESC}
    ${GREEN}remove${NC}  (rm)     ${MSG_HELP_REMOVE_DESC}
    ${GREEN}switch${NC}  (s)      ${MSG_HELP_SWITCH_DESC}
    ${GREEN}settings${NC}         ${MSG_HELP_SETTINGS_DESC}
    ${GREEN}help${NC}    (-h)     ${MSG_HELP_HELP_DESC}

${BOLD}${MSG_HELP_EXAMPLES}:${NC}
    shuu                      # ${MSG_MENU_TITLE}
    shuu create               # ${MSG_HELP_CREATE_DESC}
    shuu "implement auth"     # ${MSG_HELP_DIRECT_DESC}
    shuu ls                   # ${MSG_HELP_LIST_DESC}
    shuu s                    # ${MSG_HELP_SWITCH_DESC}
    shuu rm                   # ${MSG_HELP_REMOVE_DESC}

${BOLD}${MSG_HELP_NOTES}:${NC}
    ${MSG_HELP_NOTE_PATH}
    ${MSG_HELP_NOTE_SWITCH}

HELP
}

# ── banner ───────────────────────────────────────────────────────────

_show_banner() {
    local model
    model="$(_get_model)"
    if [[ -z "$model" ]]; then
        model="$MSG_MODEL_NONE"
    fi

    local repo_info="-"
    local branch_info="-"
    local wt_count="-"
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        repo_info="$(basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo '-')"
        branch_info="$(git branch --show-current 2>/dev/null || echo '-')"
        wt_count="$(git worktree list 2>/dev/null | wc -l | tr -d ' ')"
    fi

    printf "\n" >&2
    printf "  ${DIM}──${NC} ${YELLOW}${BOLD}shuu${NC} ${DIM}v${VERSION} ────────────────────────────────────${NC}\n" >&2
    printf "\n" >&2
    printf "  ${GREEN}      /\\\\${NC}           ${BOLD}Git Worktree Manager${NC}\n" >&2
    printf "  ${GREEN}     /  \\\\${NC}\n" >&2
    printf "  ${GREEN}    /    \\\\${NC}         ${DIM}Model  ${NC} %s\n" "$model" >&2
    printf "  ${GREEN}   /______\\\\${NC}        ${DIM}Repo   ${NC} %s ${DIM}(%s)${NC}\n" "$repo_info" "$branch_info" >&2
    printf "  ${GREEN}      ||${NC}           ${DIM}Trees  ${NC} %s\n" "$wt_count" >&2
    printf "\n" >&2
    printf "  ${DIM}──────────────────────────────────────────────${NC}\n" >&2
}

# ── interactive ──────────────────────────────────────────────────────

cmd_interactive() {
    _show_banner
    local items=(
        "$MSG_MENU_CREATE"
        "$MSG_MENU_LIST"
        "$MSG_MENU_REMOVE"
        "$MSG_MENU_SWITCH"
        "$MSG_MENU_SETTINGS"
        "$MSG_MENU_HELP"
    )
    local selected
    selected=$(select_menu "$MSG_MENU_TITLE" "${items[@]}") || return 0

    case "$selected" in
        0) cmd_create ;;
        1) cmd_list ;;
        2) cmd_remove ;;
        3) cmd_switch ;;
        4) cmd_settings ;;
        5) cmd_help ;;
    esac
}

# ── Main ─────────────────────────────────────────────────────────────

main() {
    _check_first_run

    if [[ $# -eq 0 ]]; then
        cmd_interactive
        return
    fi

    local cmd="$1"
    case "$cmd" in
        create|c)
            shift
            cmd_create "$*"
            ;;
        list|l|ls)      cmd_list ;;
        remove|rm)      cmd_remove ;;
        switch|s)       cmd_switch ;;
        settings)       cmd_settings ;;
        help|-h|--help) cmd_help ;;
        *)
            # Non-subcommand arguments treated as description for direct create
            cmd_create "$*"
            ;;
    esac
}

main "$@"
